## Algorithm
```
import com.daxiyan.study.base.algorithm.tree.TreeUtil;

/**
 * https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
 * hong.zheng
 * 114
 * @Date: 2020-05-11 21:03
 **/
public class Flatten {
    public static void main(String args[])
    { 
        TreeNode root = TreeUtil.createTree();
        flatten(root);
        TreeUtil.preOrderTraversal(root);
        System.out.println();
        TreeUtil.inorderTraversal(root);
        System.out.println();
    }

    /**
     *
     * @param root
     */
    public static void flatten(TreeNode root) {
        if(root == null){
            return ;
        }
        // 将左子树处理成链表
        flatten(root.left);
        // 将右子树处理成链表
        flatten(root.right);
        // 使用左子树 构建右子树
        buildRight(root,root.left);
        root.left = null;
    }

    /**
     *
     * @param root
     * @param left
     */
    public static void  buildRight(TreeNode root,TreeNode left) {
        TreeNode right = root.right;
        if(left == null){
            return ;
        }
        root.right = left;

        while (left.right != null){
            left = left.right;
        }
        left.right = right;
    }
}
```
树结构的处理，使用最简单的树（树高只有一层或者两层）来写基本逻辑，然后将左子树看做一个新树，左子树就是新树的父节点。

## Review
## Tip
## Share
