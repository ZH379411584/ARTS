## Algorithm
```
/**
 * https://leetcode-cn.com/problems/surrounded-regions/
 * @author hong.zheng
 * @Date: 2020-08-03 21:18
 * 130
 **/
public class Solve {
    int[] dx = {1,-1,0,0};
    int[] dy = {0,0,1,-1};
    public static void main(String[] args)
    {
    }
    public void solve(char[][] board) {
        //这里可以只遍历四条边，但是好像影响不大。
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                boolean isBorad = i==0||j==0||i==board.length-1||j==board[0].length-1;
                if(isBorad && board[i][j]=='O'){
                    helper(board,i,j);
                }
            }
        }
        //把K改成O，其他改成X
        for(int i=0;i<board.length;i++) {
            for (int j = 0; j < board[0].length; j++) {
                board[i][j] = board[i][j] == 'K' ? 'O' : 'X';
            }
        }
    }

    void helper(char[][] board,int i,int j){
        board[i][j]='K';
        for(int k=0;k<4;k++){
            int x=i+dx[k];
            int y=j+dy[k];

            if(x>=0&&y>=0&&x<board.length&&y<board[0].length&&board[x][y]=='O'){
                helper(board,x,y);
            }
        }
    }
}
```
## Review
#### [When Programmers and Testers Collaborate](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_92/)
Something magical happens when testers and programmers start to collaborate. There is less time spent sending bugs back and forth through the defect(缺陷) tracking system. Less time is wasted trying to figure out whether something is really a bug or a new feature, and more time is spent developing good software to meet customer expectations. There are many opportunities for starting collaboration before coding even begins.

Testers can help customers write and automate acceptance tests using the language of their domain with tools such as Fit (Framework for Integrated Test). When these tests are given to the programmers before they coding begins, the team is practicing Acceptance Test Driven Development (ATDD). The programmers write the fixtures to run the tests, and then code to make the tests pass. These tests then become part of the regression（回归） suite. When this collaboration occurs, the functional tests are completed early allowing time for exploratory testing on edge conditions or through workflows of the bigger picture.

We can take it one step further. As a tester, I can supply most of my testing ideas before the programmers start coding a new feature. When I ask the programmers if they have any suggestions, they almost always provide me with information that helps me with better test coverage, or helps me to avoid spending a lot of time on unnecessary tests. Often we have prevented defects because the tests clarify many of the initial ideas. For example, in one project I was on, the Fit tests I gave the programmers displayed the expected results of a query to respond to a wildcard（通配符） search. The programmer had fully intended to code only complete word searches. We were able to talk to the customer and determine the correct interpretation before coding started. By collaborating, we prevented the defect, which saved us both a lot of wasted time.

Programmers can collaborate with testers to create successful automation as well. They understand good coding practices and can help testers set up a robust test automation suite that works for the whole team. I have often seen test automation projects fail because the tests are poorly designed. The tests try to test too much or the testers haven't understood enough about the technology to be able to keep tests independent. The testers are often the bottleneck, so it makes sense for programmers to work with them on tasks like automation. Working with the testers to understand what can be tested early, perhaps by providing a simple tool, will give the programmers another cycle of feedback which will help them deliver better code in the long run.

When testers stop thinking their only job is to break the software and find bugs in the programmers' code, programmers stop thinking that testers are 'out to get them,' and are more open to collaboration. When programmers start realizing they are responsible for building quality into their code, testability of the code is a natural by-product, and the team can automate more of the regression（回归） tests together. The magic of successful teamwork begins.

summary  

测试人员编写自动化验收测试用例，这些测试用例可以在编码前就给到开发人员，开发人员运行测试用例并通过测试。测试人员需要做的就是回归测试，当这种合作产生时，功能测试尽早完成，从而有时间进行边缘条件或更大范围的工作流的探索性测试。

我们也可以更进一步，测试人员可以为新特性提供一些测试方案。开发人员可以帮助测试人员更好覆盖测试用例，创建更成功的自动测试。

测试人员和开发合作会让效率更高
1. 测试人员参与到测试人员的用例编写中，以免测试人员花费不必要的时间和精力在不需要测试的功能上。
2. 测试人员可以提供给开发人员自动验收测试用例，这样开发人员可以尽早发现自己的问题，而测试人员只需要回归测试就行了。
3. 开发人员可以协助 测试人员进行自动测试功能的开发。

#### [Write Code as If You Had to Support It for the Rest of Your Life](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_93/)
You could ask 97 people what every programmer should know and do, and you might hear back 97 distinct answers. This could be both overwhelming and intimidating at the same time. All advice is good, all principles are sound, and all stories are compelling, but where do you start? More important, once you have started, how do you keep up with all the best practices you've learned and how do you make them an integral（不可或缺的一部分） part of your programming practice?

I think the answer lies（在于） in your frame of mind or, more plainly, in your attitude. If you don't care about your fellow developers, testers, managers, sales and marketing people, and end users, then you will not be driven to employ Test-Driven Development or write clear comments in your code, for example. I think there is a simple way to adjust your attitude and always be driven to deliver the best quality products:
```
Write code as if you had to support it for the rest of your life.
```
That's it. If you accept this notion, many wonderful things will happen. If you were to accept that any of your previous or current employers had the right to call you in the middle of the night, asking you to explain the choices you made while writing the fooBar method, you would gradually improve toward becoming an expert programmer. You would naturally want to come up with better variable and method names. You would stay away from blocks of code comprising hundreds of lines. You would seek, learn, and use design patterns. You would write comments, test your code, and refactor continually. Supporting all the code you'd ever written for the rest of your life should also be a scalable endeavor（努力）. You would therefore have no choice but to become better, smarter, and more efficient.

If you reflect on it, the code you wrote many years ago still influences your career, whether you like it or not. You leave a trail of your knowledge, attitude, tenacity, professionalism, level of commitment, and degree of enjoyment with every method and class and module you design and write. People will form opinions about you based on the code that they see. If those opinions are constantly negative, you will get less from your career than you hoped. Take care of your career, of your clients, and of your users with every line of code — write code as if you had to support it for the rest of your life.

#### [Write Small Functions Using Examples](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_94/)
We would like to write code that is correct, and have evidence on hand that it is correct. It can help with both issues to think about the "size" of a function. Not in the sense of the amount of code that implements a function — although that is interesting — but rather the size of the mathematical function that our code manifests.

For example, in the game of Go there is a condition called atari in which a player's stones may be captured by their opponent: A stone with two or more free spaces adjacent to it (called liberties) is not in atari. It can be tricky to count how many liberties a stone has, but determining atari is easy if that is known. We might begin by writing a function like this:
```
boolean atari(int libertyCount)
    libertyCount < 2
```
This is larger than it looks. A mathematical function can be understood as a set, some subset of the Cartesian product of the sets that are its domain (here, int) and range (here, boolean). If those sets of values were the same size as in Java then there would be 2L*(Integer.MAX_VALUE+(-1L*Integer.MIN_VALUE)+1L) or 8,589,934,592 members in the set int×boolean. Half of these are members of the subset that is our function, so to provide complete evidence that our function is correct we would need to check around 4.3×109 examples.

This is the essence of the claim that tests cannot prove the absence of bugs. Tests can demonstrate the presence of features, though. But still we have this issue of size.

The problem domain helps us out. The nature of Go means that number of liberties of a stone is not any int, but exactly one of {1,2,3,4}. So we could alternatively write:
```
LibertyCount = {1,2,3,4} 
boolean atari(LibertyCount libertyCount)
    libertyCount == 1
```
This is much more tractable(易处理的): The function computed is now a set with at most eight members. In fact, four checked examples would constitute evidence of complete certainty that the function is correct. This is one reason why it's a good idea to use types closely related to the problem domain to write programs, rather than native types. Using domain–inspired types can often make our functions much smaller. One way to find out what those types should be is to find the examples to check in problem domain terms, before writing the function.

#### [Write Tests for People](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_95/)
You are writing automated tests for some or all of your production code. Congratulations! You are writing your tests before you write the code? Even better!! Just doing this makes you one of the early adopters on the leading edge of software engineering practice. But are you writing good tests? How can you tell? One way is to ask "Who am I writing the tests for?" If the answer is "For me, to save me the effort of fixing bugs" or "For the compiler, so they can be executed" then the odds are you aren't writing the best possible tests. So who should you be writing the tests for? For the person trying to understand your code.

Good tests act as documentation for the code they are testing. They describe how the code works. For each usage scenario the test(s):

1. Describe the context, starting point, or preconditions that must be satisfied
2. Illustrate how the software is invoked(调用)
3. Describe the expected results or postconditions to be verified

Different usage scenarios will have slightly different versions of each of these. The person trying to understand your code should be able to look at a few tests and by comparing these three parts of the tests in question, be able to see what causes the software to behave differently. Each test should clearly illustrate the cause and effect relationship between these three parts. This implies that what isn't visible in the test is just as important as what is visible. Too much code in the test distracts the reader with unimportant trivia. Whenever possible hide such trivia behind meaningful method calls — the Extract Method refactoring is your best friend. And make sure you give each test a meaningful name that describes the particular usage scenario so the test reader doesn't have to reverse engineer each test to understand what the various scenarios are. Between them, the names of the test class and class method should include at least the starting point and how the software is being invoked. This allows the test coverage to be verified via a quick scan of the method names. It can also be useful to include the expected results in the test method names as long as this doesn't cause the names to be too long to see or read.

It is also a good idea to test your tests. You can verify they detect the errors you think they detect by inserting those errors into the production code (your own private copy that you'll throw away, of course). Make sure they report errors in a helpful and meaningful way. You should also verify that your tests speak clearly to a person trying to understand your code. The only way to do this is to have someone who isn't familiar with your code read your tests and tell you what they learned. Listen carefully to what they say. If they didn't understand something clearly it probably isn't because they aren't very bright. It is more likely that you weren't very clear. (Go ahead and reverse the roles by reading their tests!)



## Tip
## Share
