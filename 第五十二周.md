## Algorithm
```
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
 * hong.zheng
 * 94
 * @Date: 2020-03-16 08:55
 **/
public class InorderTraversal {
    public static void main(String args[])
    {
        createTreeNode();
    }

    public static List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if(null==root){
            return result;
        }
        inorderTraversal(root,result);

        return result;
    }

    public static TreeNode  createTreeNode(){
        Integer[] array = {1,null,2,3};



        TreeNode parentNode = new TreeNode(1);

        createTreeNode(parentNode,array,0);
        inorderTraversal(parentNode);
        return parentNode;
    }

    /**
     * 前序遍历创建
     * @param treeNode
     * @param array
     * @param index
     * @return
     */
    public static Integer  createTreeNode(TreeNode treeNode, Integer[] array,int index){
        if(index >= array.length){
            return index;
        }
        Integer leftIndex = index+1;
        //构建左子树
        if(index+1 < array.length && array[index+1] !=null){
            treeNode.left = new TreeNode(array[index+1]);
            leftIndex = createTreeNode(treeNode.left,array,index+2);
        }
        //创建右子树
        if(leftIndex+1 < array.length  && array[leftIndex+1] !=null ){
            treeNode.right = new TreeNode(array[leftIndex+1]);
            createTreeNode(treeNode.right,array,leftIndex+1);
        }
        return index+1;

    }




    public static void inorderTraversal(TreeNode root,List<Integer> result){
        if(null!=root.left){
            inorderTraversal(root.left,result);
        }
        result.add(root.val);
        System.out.println(root.val);
        if(null!=root.right){
            inorderTraversal(root.right,result);
        }
    }

    /**
     * 使用栈
     * @param root
     * @return
     */
    public static List<Integer>  inorderTraversalStack(TreeNode root){
        Stack<TreeNode> treeNodes  = new Stack<>();
        List<Integer> result = new ArrayList<>();

        TreeNode current = root;

        while (!treeNodes.isEmpty() || current!=null){
            while (current!=null){
                //
                treeNodes.push(current);
                current = current.left;
            }
            current = treeNodes.pop();
            // 中序遍历
            result.add(current.val);
            current = current.right;

        }
        return result;
    }
}
``` 
## Review
## Tip
## Share
