## Algorithm
```
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
 * hong.zheng
 * 94
 * @Date: 2020-03-16 08:55
 **/
public class InorderTraversal {
    public static void main(String args[])
    {
        createTreeNode();
    }

    public static List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if(null==root){
            return result;
        }
        inorderTraversal(root,result);

        return result;
    }

    public static TreeNode  createTreeNode(){
        Integer[] array = {1,null,2,3};



        TreeNode parentNode = new TreeNode(1);

        createTreeNode(parentNode,array,0);
        inorderTraversal(parentNode);
        return parentNode;
    }

    /**
     * 前序遍历创建
     * @param treeNode
     * @param array
     * @param index
     * @return
     */
    public static Integer  createTreeNode(TreeNode treeNode, Integer[] array,int index){
        if(index >= array.length){
            return index;
        }
        Integer leftIndex = index+1;
        //构建左子树
        if(index+1 < array.length && array[index+1] !=null){
            treeNode.left = new TreeNode(array[index+1]);
            leftIndex = createTreeNode(treeNode.left,array,index+2);
        }
        //创建右子树
        if(leftIndex+1 < array.length  && array[leftIndex+1] !=null ){
            treeNode.right = new TreeNode(array[leftIndex+1]);
            createTreeNode(treeNode.right,array,leftIndex+1);
        }
        return index+1;

    }




    public static void inorderTraversal(TreeNode root,List<Integer> result){
        if(null!=root.left){
            inorderTraversal(root.left,result);
        }
        result.add(root.val);
        System.out.println(root.val);
        if(null!=root.right){
            inorderTraversal(root.right,result);
        }
    }

    /**
     * 使用栈
     * @param root
     * @return
     */
    public static List<Integer>  inorderTraversalStack(TreeNode root){
        Stack<TreeNode> treeNodes  = new Stack<>();
        List<Integer> result = new ArrayList<>();

        TreeNode current = root;

        while (!treeNodes.isEmpty() || current!=null){
            while (current!=null){
                //
                treeNodes.push(current);
                current = current.left;
            }
            current = treeNodes.pop();
            // 中序遍历
            result.add(current.val);
            current = current.right;

        }
        return result;
    }
}
``` 
## Review
#### [Don't Rely on "Magic Happens Here" 不要依赖“魔法发生在这里”](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_29/)
If you look at any activity, process, or discipline from far enough away it looks simple. Managers with no experience of development think what programmers do is simple and programmers with no experience of management think the same of what managers do.

Programming is something some people do — some of the time. And the hard part — the thinking — is the least visible and least appreciated by the uninitiated.(编程有时是某些人的工作。而最难的部分-思想-是新手看不到的东西和最欣赏不到的东西。) There have been many attempts to remove the need for this skilled thinking over the decades. One of the earliest and most memorable(难忘的) is the effort by Grace Hopper to make programming languages less cryptic(隐秘的) — which some accounts predicted would remove the need for specialist programmers. The result (COBOL) has contributed to the income of many specialist programmers over subsequent decades.

The persistent vision that software development can be simplified by removing programming is, to the programmer who understands what is involved, obviously naïve（幼稚的）. But the mental process that leads to this mistake is part of human nature and programmers are just as prone to making it as everyone else.

On any project there are likely many things that an individual programmer doesn't get actively involved in: eliciting requirements from users, getting budgets approved, setting up the build server, deploying the application to QA and production environments, migrating the business from the old processes or programs, etc.

When you aren't actively involved in things there is an unconscious tendency to assume that they are simple and happen "by magic." While the magic continues to happen all is well. But when — it is usually "when" and not "if" — the magic stops the project is in trouble. （当您不积极参与事物时，就会有一种潜意识的倾向，即认为它们是简单的并“通过魔法”发生。当魔法继续发生时，一切都很好。但是，当魔法通常是“何时”而不是“如果”时，魔法就停止了该项目的麻烦。）

I've known projects lose weeks of developer time because no one understood how they relied on "the right" version of a DLL being loaded. When things started failing intermittently team members looked everywhere else before someone noticed that "a wrong" version of the DLL was being loaded.

Another department was running smoothly — projects delivered on time, no late night debugging sessions, no emergency fixes. So smoothly, in fact, that senior management decided that things "ran themselves" and they could do without the project manager. Inside six months the projects in the department looked just like the rest of the organization — late, buggy and continually being patched.

You don't have to understand all the magic that makes your project work, but it doesn't hurt to understand some of it — or to appreciate someone who understands the bits you don't.

Most importantly, make sure that when the magic stops it can be started again.

#### [Don't Repeat Yourself](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_30/)

Of all the principles of programming, Don't Repeat Yourself (DRY) is perhaps one of the most fundamental. The principle was formulated by Andy Hunt and Dave Thomas in The Pragmatic Programmer, and underlies many other well-known software development best practices and design patterns. The developer who learns to recognize duplication, and understands how to eliminate it through appropriate practice and proper abstraction, can produce much cleaner code than one who continuously infects the application with unnecessary repetition.

##### Duplication is waste
Every line of code that goes into an application must be maintained, and is a potential source of future bugs. Duplication needlessly bloats the codebase, resulting in more opportunities for bugs and adding accidental complexity to the system. The bloat that duplication adds to the system also makes it more difficult for developers working with the system to fully understand the entire system, or to be certain that changes made in one location do not also need to be made in other places that duplicate the logic they are working on. DRY requires that "every piece of knowledge must have a single, unambiguous, authoritative representation within a system." (DRY requires that  每条knowledge都必须在系统中具有单一，明确，权威的表示形式。)
##### Repetition in process calls for automation (流程重复要求自动化)
Many processes in software development are repetitive and easily automated.(重复且易于自动化) The DRY principle applies in these contexts as well as in the source code of the application. Manual testing is slow, error-prone, and difficult to repeat, so automated test suites should be used, if possible. Integrating software can be time consuming and error-prone if done manually, so a build process should be run as frequently as possible, ideally with every check-in. Wherever painful manual processes exist that can be automated, they should be automated and standardized. The goal is to ensure there is only one way of accomplishing the task, and it is as painless as possible.
##### Repetition in logic calls for abstraction

Repetition in logic can take many forms. Copy-and-paste if-then or switch-case logic is among the easiest to detect and correct. Many design patterns have the explicit goal of reducing or eliminating duplication in logic within an application. If an object typically requires several things to happen before it can be used, this can be accomplished with an Abstract Factory or a Factory Method. If an object has many possible variations in its behavior, these behaviors can be injected using the Strategy pattern rather than large if-then structures. In fact, the formulation(公式) of design patterns themselves is an attempt to reduce the duplication(复制) of effort required to solve common problems and discuss such solutions. In addition, DRY can be applied to structures, such as database schema, resulting in normalization.
##### A Matter of principle 原则问题
Other software principles are also related to DRY. The Once and Only Once principle, which applies only to the functional behavior of code, can be thought of as a subset of DRY. The Open/Closed Principle, which states that "software entities should be open for extension, but closed for modification," only works in practice when DRY is followed. Likewise, the well-known Single Responsibility Principle requires that a class have "only one reason to change," relies on DRY.

When followed with regard to structure, logic, process, and function, the DRY principle provides fundamental guidance to software developers and aids the creation of simpler, more maintainable, higher-quality applications. While there are scenarios where repetition can be necessary to meet performance or other requirements (e.g., data denormalization in a database), it should be used only where it directly addresses an actual rather than an imagined problem.
#### [Don't Touch that Code!](https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_31/)

## Tip
## Share
